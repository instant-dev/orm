# Instant ORM
![npm version](https://img.shields.io/npm/v/@instant.dev/orm?label=) ![Build Status](https://app.travis-ci.com/instant-dev/orm.svg?branch=main)

## JavaScript ORM for Postgres

This is the core ORM package for [**`instant.dev`**](https://github.com/instant-dev/instant).
It is recommended that you use it with the `instant` command line utility
available at [instant-dev/instant](https://github.com/instant-dev/instant) for
easy migration management, **however, it can be used as a standalone ORM**. By
default, upon connecting to a database, the Instant ORM will introspect your
Database schema and determine appropriate models and relationships.

## Getting Started

Installing the Instant ORM:

```shell
npm i @instant.dev/orm@latest --save
```

Initializing (CommonJS):

```javascript
const InstantORM = require('@instant.dev/orm');
const Instant = new InstantORM();
```

Initializing (ESM):

```javascript
import InstantORM from '@instant.dev/orm';
const Instant = new InstantORM();
```

## Connecting to a Database

By default, the Instant ORM will attempt to load database credentials from
`_instant/db.json[process.env.NODE_ENV]["main"]`:

```javascript
await Instant.connect(); // connects based on _instant/db.json
```

However, you can also provide custom credentials to any database you'd like
by passing in a `cfg` configuration object with the credentials in the following
format:

```javascript
const cfg = {
  host: 'my.postgres.host',
  port: 5432,
  user: 'postgres',
  password: '',
  database: 'postgres',
  ssl: false, // optional: acceptable values are [true, false, "unauthorized"]
  in_vpc: false, // optional: if false, will use provided SSH tunnel when deployed
  tunnel: { // optional: use this if we need to SSH tunnel into database
    host: 'my.ssh.host.com',
    port: 22,
    user: 'ec2-user',
    private_key: 'path/to/private_key.pem'
  }
};
await Instant.connect(cfg); // now connected to custom Database
```

You can also opt to provide a `connectionString` instead:

```javascript
const cfg = {
  connectionString: 'postgres://postgres:mypass@my.postgres.host:5432/postgres?sslmode=true',
  in_vpc: false, // optional: if false, will use provided SSH tunnel when deployed
  tunnel: { // optional: use this if we need to SSH tunnel into database
    host: 'my.ssh.host.com',
    port: 22,
    user: 'ec2-user',
    private_key: 'path/to/private_key.pem'
  }
};
await Instant.connect(cfg); // now connected to custom Database
```

### Connecting to another database

By default, the `Instant.connect()` method will assign your initial database
connection the alias `"main"`. You can access your Database object directly
via:

```javascript
const db = Instant.database();
const mainDb = Instant.database('main');
console.log(db === mainDb); // true, "main" is an alias for your main db
```

To connect to another database, simply use:

```javascript
// connect
Instant.addDatabase(name, cfg);
// read
const otherDb = Instant.database(name);
```

### Querying your databases directly

Querying your database directly is easy. To run a standalone query;

```javascript
const db = Instant.database();
const result = await db.query(`SELECT * FROM my_table WHERE x = $1`, [27]);
```

To execute a batched transaction from prepared statements and queries;

```javascript
const db = Instant.database();
// Pass in an array of statements
const result = await db.transact([
  `SELECT * FROM my_table`,
  `INSERT INTO my_table(field) VALUES((1))`,
  // Parameterized statements can be passed in as well
  [`INSERT INTO my_other_table(other_field) VALUES(($1))`, [2]]
]);
```

And to create a transaction that you want to work with in real-time, potentially
querying third party services before deciding whether or not to commit the query:

```javascript
const db = Instant.database();
const txn = db.createTransaction();

let result = await txn.query(`SELECT * FROM my_table WHERE x = $1`, [27]);
let result2 = await txn.query(`INSERT INTO my_table(field) VALUES(($1))`, [5]);
let manyQueries = await txn.transact([
  `SELECT * FROM my_table`,
  `INSERT INTO my_table(field) VALUES((1))`,
]);
// to commit
await txn.commit();
// to rollback
await txn.rollback();
```

### Disconnecting

To disconnect from a specific database:

```javascript
Instant.closeDatabase(name);
```

And to disconnect from all open databases and reset your connection:

```javascript
Instant.disconnect();
```

## Loading a Schema

When you connect to a database, Instant ORM will attempt to determine the
schema of your database in a few ways.

- First, it will check to see if `_instant/cache/schema.json` exists
  - If it does, it will load the schema from this file
- Next, it will check to see if an `_instant_migrations` table exists in your
  database
  - This table holds all migrations applied to the database and is generated by
    the [instant.dev](https://github.com/instant-dev/instant) CLI automatically
  - If it does exist and has entries, it will load the schema from the latest
    migration
- Finally, it will introspect your database structure
  - All tables, columns, sequences and constraints will be inspected
  - Foreign keys and uniqueness will be used to determine one-to-one and
    one-to-many relationships

Additionally, you can also pass a custom `schema` object to the
`Instant.connect(cfg)` method as a second argument, but this is
**not recommended**. It is usually reserved for testing purposes.

## Loading Custom Model Logic

By default, the Instant ORM will load models from the `_instant/models`
directory.
**You do not need a model file for every, or even any, table in your database**.
These are only meant to extend models in the case you want to add Lifecycle
callbacks, validations, verifications, calculated fields or hide data.
Each file should look something like this;

File: `_instant/models/sample_model.mjs`

```javascript
import InstantORM from '@instant.dev/orm';

class SampleModel extends Model {

  static tableName = 'sample_models';

  async beforeSave (txn) {}
  async afterSave (txn) {}
  async beforeDestroy (txn) {}
  async afterDestroy (txn) {}

}

SampleModel.calculates(/* ... */);
SampleModel.validates(/* ... */);
SampleModel.verifies(/* ... */);
SampleModel.hides(/* ... */);

export default SampleModel;
```

The Instant ORM will automatically associate each file with the appropriate
table in your database schema, provided `SampleModel.tableName` matches a table
on your Database. You can access your Models using;

```javascript
// Note that "SampleModels", "samplemodel", "sample_models" etc.
// will all work as well as long as there's no ambiguity
Instant.Model('SampleModel');
```

## Using Models

Models are accessible via the `Instant.Model(modelName)` method. This method
will automatically look up the most likely model based on the matching `table`
in your database schema.

```javascript
const User = Instant.Model('User');
```

This method would also accept the strings `Users`, `user`, `users`. If your
table has pluralization and underscores we recommend using the singular version,
but you can access using the table name as well. For example, the table name
`object_children` could be accessed via:

```javascript
const ObjectChild = Instant.Model('ObjectChild'); // recommended
```

However, the following would also work:

```javascript
Instant.Model('ObjectChildren');
Instant.Model('object_child');
Instant.Model('object_children');
```

In the case of ambiguity - multiple tables potentially matching the object name -
`Instant.Model()` will throw an error and ask you to use the specific table.

### CRUD Operations

#### Create

You can create new model instances and save them to the database with
`Model.create(data)` or `new Model(data)` and then a subsequent `model.save()`:

```javascript
const User = Instant.Model('User');

// Model.create() method creates a user:
let user1 = await User.create({email: 'keith@instant.dev', username: 'keith'});
console.log(user1.inStorage()); // true

// Can also use new Model() and then save it
let user2 = new User({email: 'scott@instant.dev'});
user2.set('username', 'scott'); // can set values independently
console.log(user2.inStorage()); // false
await user2.save();
console.log(user2.inStorage()); // true
```

#### Read

Reading model data can be done in a few ways: `Model.find()`, `Model.findBy()`
or via [Query composition](#query-composition) using the `query.select()`
method.

```javascript
let user1 = await User.find(1); // uses id
let user2 = await User.findBy('email', 'keith@instant.dev');
let user3 = await User.query()
  .where({email: 'keith@instant.dev'})
  .first(); // throws error if not found
let userList = await User.query()
  .where({email: 'keith@instant.dev'})
  .select(); // can return an empty list
let userCount = await User.query()
  .where({email: 'keith@instant.dev'})
  .count();
```

#### Update

Updating model data can be performed by (1) updating and saving individual
models, (2) update and saving ModelArrays, (3) `Model.updateOrCreateBy()` or
(4) [Query composition](#query-composition) using the `query.update()` method.

**Note:** `query.update()` will bypass model lifecycle methods `beforeSave()`
and `afterSave()` as well as all validations verifications. Read more in
[Lifecycle callbacks](#lifecycle-callbacks).

```javascript
let user = await user.findBy('username', 'keith');
user.set('username', 'keith_h');
await user.save();

// Update by reading from data
user.read({username: 'keith_h2'});
await user.save();

// Save many models at once using ModelArrays
// Let's make all our moderators superusers
let users = await User.query()
  .where({is_moderator: true})
  .select();
users.setAll('is_superuser', true);
await users.saveAll();

// Can also use `readAll`
users.readAll({free_credits: 100});
await users.saveAll();

// Can update models directly with new data if there's a matching entry
user = await User.updateOrCreateBy(
  'username',
  {username: 'keith_h2', email: 'keith+new@instant.dev'}
);

// Bypass lifecycle callbacks, validations and verifications
// Useful for updating many models at once and batch processing
users = await User.query()
  .where({username: 'keith_h2'})
  .update({username: 'keith'});
```

##### Incrementing values and custom SQL

You can run custom SQL when updating models using the `query.update()` method.
**This will bypass [Lifecycle callbacks](#lifecycle-callbacks)**. However it is
the most efficient way to do things like incrementing values.

```javascript
const user = User.findBy('email', 'keith@instant.dev');
await User.query()
  .where({user_id: user.get('id')})
  .update({post_count: (post_count) => `${post_count} + 1`});
```

In this case, the `post_count` variable will hold the query column reference.
You can reference multiple fields by including more fields in the function
arguments:

```javascript
const user = User.findBy('email', 'keith@instant.dev');
await User.query()
  .where({user_id: user.get('id')})
  .update({
    post_count: (post_count) => `${post_count} + 1`,
    karma: (karma, post_count) => `${karma} + LOG(${post_count})`
  });
```

Any valid SQL expression can be returned by these methods.

#### Destroy

We purposefully **do not** include a `delete` method in
[Query composition](#query-composition). In most application contexts,
permanently deleting records is bad practice from a security and monitoring
perspective. We usually recommend `is_archived` or `is_deleted` flags.
In the case you really do need to delete records, there is a `Model.destroy(id)`
method, a `model.destroy()` method and a `modelArray.destroyAll()` method.
We also provide `model.destroyCascade()` and `modelArray.destroyCascade()` for
a cascading delete if foreign key constraints prevent deleting a model directly.

```javascript
await User.destroy(100); // goodbye User(id=100)!

let user = await User.findBy('email', 'nouser@instant.dev');
await user.destroy();
let user2 = await User.findBy('email', 'nouser2@instant.dev');
await user2.destroyCascade(); // destroy model + children (useful for foreign keys)

/* ModelArray methods */
let bannedUsers = await User.query().where({is_banned: true}).select();
await bannedUsers.destroyAll();

let mutedUsers = await User.query().where({is_muted: true}).select();
await mutedUsers.destroyCascade();
```

### Query composition

Write me!

### Transactions

Write me!!

### Input validation

Write me!!!

### Relationship verification

Write me!!!!

### Calculated fields

Write me!!!!!

### Lifecycle callbacks

Write me!!!!!!

## Using Migrations, Seeding and Code Generation

Migrations, seeds and code generation can be managed via the
[instant.dev](https://github.com/instant-dev/instant) CLI.

## Acknowledgements

Thank you!
